/**********************************************************************
  TM.c:

     TM.c is a subroutine to calculate norm conseving pseudo
     potentials using TM's scheme.

  Log of TM.c:

     10/Nov/2002  Released by T.Ozaki
     20/Mar/2003  Modified by T.Ozaki

***********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include "adpack.h"

static void Calc_new_range(/*input */
                     int *node_c_ene, double *DD_c_ene, int num_nodes,
                    /*output*/
                    double *MinE, double *MaxE , double *dE, int *num_div );

static void Calc_PAO(int state_num,
                     int so, int n, int l, int num_nodes, double Reduce_Num_grid,
                     double Vps[ASIZE1], double pw[ASIZE1]);
static double Norm_Core(double af[ASIZE1], double rc);
static double Norm_Core2(int l,double rc,
                         double c0,
                         double c2,
                         double c4,
                         double c6,
                         double c8,
                         double c10,
			 double c12);
static double Dlog_Norm(int l,
                        double a[ASIZE6][ASIZE6],
                        double a0[ASIZE6][ASIZE6],
                        double b[ASIZE6], double c[ASIZE6], double c2,
                        double Ncore,
			double rc, double r2, double r3, double r4);
static void Spline_Func(double R, double fv[3], double af[ASIZE1]);
static int Calc_VPS_PAO(int calc_type,
                        int so, int l, double rc, double ep, double scale_factor, 
                        double AEW[ASIZE1], double AEV[ASIZE1],
                        double  PW[ASIZE1], double PEV[ASIZE1]);
static double ip_phi0_phi1(double phi0[ASIZE1],double phi1[ASIZE1],double rc);
static void Hamman(int so,int L,double rc,double ep,double PW[ASIZE1],double PV[ASIZE1]);






void TM(int state_num)
{ 
  static int m,n,l,i,j,ip,po,po1,numvps,ll,mul,mul1;
  static int m1,n1,loop_num,loop_max,num_nodes,so;
  static double max_SF,r,ef;
  static double ep,rc,a2,sum,dnorm,da,dnorm_p;
  static double a_p,lower_a,upper_a,lower_d,upper_d;
  static double PseudoW[ASIZE4][ASIZE1],PseudoV[ASIZE4][ASIZE1];
  static double W3[ASIZE4][ASIZE1],V3[ASIZE1];
  char *s_vec[20];

  /**************************************
    read a file for EDPP
  **************************************/
  
  if (VPP_switch==3) {
    i = Restart_load(state_num);
    if (i==0){
      printf("Could not find a file which stores informations of AE calculation.\n");
      exit(0);
    }  
  }

  /**************************************
          start the calculations
  **************************************/

  for (so=0; so<SOI_switch; so++){
    for (l=0; l<ASIZE2; l++){

      s_vec[0]="None";      s_vec[1]="TM+KB";
      s_vec[2]="TM+Blochl"; s_vec[3]="Vanderbilt with a single potential";
      s_vec[4]="None";      s_vec[5]="Hamman+TM+Blochl";      

      if (NL_type[l]!=0){
	printf("<VPS>  VPS of SO=%i L=%d is generated by %s scheme\n",so,l,s_vec[NL_type[l]]);
      }

      if (NumVPS_L[l]!=0){

        /* Hamman's scheme */

        if (NL_type[l]==5){

  	  m = GI_VPS[l][0];
	  n = NVPS[m];
	  rc = VPS_Rcut[m];
          ep = 0.0;

	  printf("<VPS>  Generating VPS of SO=%d n=%d l=%d by the Hamman+TM scheme....\n",so,n,l);
	  printf("<VPS>  Used cutoff radius for VPS=%10.7f (a.u.)\n",rc);

          Hamman(so,l,rc,ep,PF[so][n][l],V_all_ele);
        
          po1 = Calc_VPS_PAO(0,so,l,rc,ep,1.0,PF[so][n][l],V,W2[so][m],V2[so][m]);
        }

        /* TM's scheme */

        else {
  	  m = GI_VPS[l][0];
	  n = NVPS[m];
	  rc = VPS_Rcut[m];
	  ep = E[state_num][so][n][l];

	  printf("<VPS>  Generating VPS of SO=%d n=%d l=%d by the TM scheme....\n",so,n,l);
	  printf("<VPS>  Used cutoff radius for VPS=%10.7f (a.u.)\n",rc);

          po1 = Calc_VPS_PAO(0,so,l,rc,ep,1.0,PF[so][n][l],V,W2[so][m],V2[so][m]);
          
          for (mul=1; mul<NumVPS_L[l]; mul++){
            
            m1 = GI_VPS[l][mul]; 
  	    n1 = NVPS[m1];
            
	    Calc_PAO(state_num,so,n1,l,mul,RNG[n1][l],V2[so][m],W2[so][m1]);
            
 	    for (i=0; i<Grid_Num; i++){
              V2[so][m1][i] = V2[so][m][i];
            }
          }

	}
      }
    } /* l */ 
  } /* so */

  Density_V(state_num,OcpN);
  Hartree(rho_V[state_num],Vh_V);

  if (PCC_switch==0){
    if      (XC_switch==0) XC_CA(rho_V[state_num],Vxc_V,1);
    else if (XC_switch==1) XC4atom_PBE(rho_V[state_num],Vxc_V,1);
  }
  else {
    Density_PCC(rho_PCC,state_num,OcpN);
    for (i=0; i<Grid_Num; i++){
      rho[1][i] = rho_V[state_num][i] + rho_PCC[i];
    }
    if      (XC_switch==0) XC_CA(rho[1],Vxc_V,1);
    else if (XC_switch==1) XC4atom_PBE(rho[1],Vxc_V,1);
  }
  
  for (so=0; so<SOI_switch; so++){
    for (m=0; m<Number_VPS; m++){
      for (i=0; i<Grid_Num; i++){
        VPS[state_num][so][m][i] = V2[so][m][i] - Vh_V[i] - Vxc_V[i];
      }
    }
  }

  po = 0;
  sum = 0.0;
  i = 0;
  do {
    sum += 4.0*PI*(rho[0][i]-rho_V[state_num][i])*MRV[i]*MRV[i]*MRV[i]*dx;

    /* more than 99.0% */
    if ( (0.99*((double)AtomNum-valence_electron))<sum){ 
      po = 1;
      ip = i;
      Core_R[state_num] = MRV[ip];
    }

    i++; 
  } while (po==0 && i<Grid_Num);


  /*
  printf("Core_R[0]=%15.12f\n",Core_R[0]);
  */

  /* for std output */
  printf("\n");

}




static void Hamman(int so, int L, double rc, double ep,
                   double PW[ASIZE1], double PV[ASIZE1])
{
  int i,ic,po;
  double kappa,tmp,fugo;
  double Mo[ASIZE1],Lo[ASIZE1],DMo[ASIZE1];

  if (L==0){
    kappa = -1.0;    /* for j=l+1/2 */
  } 
  else{ 
    if      (so==0)  kappa = (double)(-L-1);    /* for j=l+1/2 */
    else if (so==1)  kappa = (double)L;         /* for j=l-1/2 */
  }

  if (Equation_Type==0){      /* Schrodinger equation */
    Hamming_O(0,L,ep,kappa,Mo,Lo,DMo,V_all_ele,V_all_ele,0.95);
  }
  else if (Equation_Type==1){ /* scalar relativistic equation */
    Hamming_O(2,L,ep,kappa,Mo,Lo,DMo,V_all_ele,V_all_ele,0.95);
  }
  else if (Equation_Type==2){ /* fully relativistic equation */
    Hamming_O(3,L,ep,kappa,Mo,Lo,DMo,V_all_ele,V_all_ele,0.95);
  }

  /* find ic corresponding to rc */

  po = 0;
  for (i=0; i<Grid_Num; i++){
    if (rc<MRV[i] && po==0){
      po = 1;
      ic = i;
    }
  }

  /* calculate PW */

  for (i=0; i<=(ic+10); i++){
    PW[i] = pow(MRV[i],(double)L+1.0)*Lo[i];
  }

  /* normalization of PW */

  tmp = 1.0/sqrt(Norm_Core(PW,rc));

  if (0.0<PW[ic]) fugo = 1.0;
  else            fugo =-1.0;  

  for (i=0; i<=(ic+10); i++){
    PW[i] = tmp*fugo*PW[i];
  }

}







double Norm_Core(double af[ASIZE1], double rc)
{
  static int i,n,j,l,nf,fg;
  static double r,rmin,rmax,Sr,Dr,sum,dum,fv[3];

  n = ASIZE7-2;
  nf = n;
  fg = 1;

  Gauss_Legendre(n,x,w,&nf,&fg);

  rmin = MRV[0];
  rmax = rc;
  Sr = rmax + rmin;
  Dr = rmax - rmin;

  sum = 0.0;
  for (i=0; i<=(n-1); i++){
    r = 0.50*(Dr*x[i] + Sr);
    Spline_Func(r,fv,af);
    sum += 0.5*Dr*fv[0]*fv[0]*w[i];
  }

  return sum;
}




double Dlog_Norm(int l,
                 double a[ASIZE6][ASIZE6],
                 double a0[ASIZE6][ASIZE6],
                 double b[ASIZE6], double c[ASIZE6], double c2,
                 double Ncore,
                 double rc, double r2, double r3, double r4)
{
  static int i,j;
  static double c0,c4,c6,c8,c10,c12;
  static double Norm2,DLN;

  for (i=0; i<=4; i++){
    for (j=0; j<=4; j++){
      a[i][j] = a0[i][j];
    }
  }

  c4 = -c2*c2/(2.0*(double)l + 5.0);

  a[0][5] = b[0] - c2*r2 - c4*r4;
  a[1][5] = b[1] - 2.0*c2*rc - 4.0*c4*r3;
  a[2][5] = b[2] - 2.0*c2 - 12.0*c4*r2;
  a[3][5] = b[3] - 24.0*c4*rc;
  a[4][5] = b[4] - 24.0*c4;

  Gauss_LEQ(4,a,c);
  c0  = c[0];
  c6  = c[1];
  c8  = c[2];
  c10 = c[3];
  c12 = c[4];
  c[5] = c4;
  Norm2 = Norm_Core2(l,rc,c0,c2,c4,c6,c8,c10,c12);
  DLN = log(Ncore) - 2.0*c0 - log(Norm2);
  return DLN;
}



double Norm_Core2(int l,double rc,
                  double c0,
                  double c2,
                  double c4,
                  double c6,
                  double c8,
                  double c10,
                  double c12)
{
  static int i,n,j,nf,fg;
  static double r1,r2,r4,r6,r8,r10,r12,p;
  static double rmin,rmax,Sr,Dr,sum,dum,fv[3];

  n = ASIZE7-2;
  nf = n;
  fg = 1;

  Gauss_Legendre(n,x,w,&nf,&fg);

  rmin = MRV[0];
  rmax = rc;
  Sr = rmax + rmin;
  Dr = rmax - rmin;

  sum = 0.0;
  for (i=0; i<=(n-1); i++){
    r1  = 0.50*(Dr*x[i] + Sr);
    r2  = r1*r1;
    r4  = r2*r2;
    r6  = r4*r2;
    r8  = r4*r4;
    r10 = r8*r2;
    r12 = r10*r2;
    p = c0 + c2*r2 + c4*r4 + c6*r6 + c8*r8 + c10*r10 + c12*r12;
    dum = pow(r1,2.0*((double)l+1.0))*exp(2.0*p - 2.0*c0);
    sum = sum + 0.5*Dr*dum*w[i];
  }
  return sum;
}


void Spline_Func(double R, double fv[3], double af[ASIZE1])
{

  static int mp_min,mp_max,m;
  static double h1,h2,h3,f1,f2,f3,f4;
  static double g1,g2,x1,x2,y1,y2,f,Df,D2f;
  static double result;

  mp_min = 4;
  mp_max = Grid_Num - 1;
 
  if (R<MRV[4]){
    m = 5;
  }
  else if (MRV[Grid_Num-1]<R){
    m = Grid_Num - 3;
  } 
  else{
    do{ 
      m = (mp_min + mp_max)/2;
      if (MRV[m]<R)
        mp_min = m;
      else 
        mp_max = m;
    }
    while((mp_max-mp_min)!=1);
    m = mp_max;
  }

  /****************************************************
                 Spline like interpolation
  ****************************************************/

  h1 = MRV[m-1] - MRV[m-2];
  h2 = MRV[m]   - MRV[m-1];
  h3 = MRV[m+1] - MRV[m];

  f1 = af[m-2];
  f2 = af[m-1];
  f3 = af[m];
  f4 = af[m+1];

  /****************************************************
                 Treatment of edge points
  ****************************************************/

  if (m==1){
    h1 = -(h2+h3);
    f1 = f4;
  }
  if (m==(Grid_Num-1)){
    h3 = -(h1+h2);
    f4 = f1;
  }

  /****************************************************
              calculate the values at R
  ****************************************************/

  g1 = ((f3-f2)*h1/h2 + (f2-f1)*h2/h1)/(h1+h2);
  g2 = ((f4-f3)*h2/h3 + (f3-f2)*h3/h2)/(h2+h3);

  x1 = R - MRV[m-1];
  x2 = R - MRV[m];
  y1 = x1/h2;
  y2 = x2/h2;

  f =  y2*y2*(3.0*f2 + h2*g1 + (2.0*f2 + h2*g1)*y2)
    + y1*y1*(3.0*f3 - h2*g2 - (2.0*f3 - h2*g2)*y1);

  Df = 2.0*y2/h2*(3.0*f2 + h2*g1 + (2.0*f2 + h2*g1)*y2)
    + y2*y2*(2.0*f2 + h2*g1)/h2
    + 2.0*y1/h2*(3.0*f3 - h2*g2 - (2.0*f3 - h2*g2)*y1)
    - y1*y1*(2.0*f3 - h2*g2)/h2;
    
  D2f =  2.0*(3.0*f2 + h2*g1 + (2.0*f2 + h2*g1)*y2)
    + 4.0*y2*(2.0*f2 + h2*g1)
    + 2.0*(3.0*f3 - h2*g2 - (2.0*f3 - h2*g2)*y1)
    - 4.0*y1*(2.0*f3 - h2*g2);
  D2f = D2f/h2/h2;

  fv[0] = f;
  fv[1] = Df;
  fv[2] = D2f;
}


int Calc_VPS_PAO(int calc_type,
                 int so, int l, double rc, double ep, double scale_factor,
                 double AEW[ASIZE1], double AEV[ASIZE1],
                 double  PW[ASIZE1], double  PV[ASIZE1])
{
  /******************************************************************
     calc_type
       0, usual
       1, search the upper bound of a scaling factor for norm
       2, making partial wave functions for linear combination
  ******************************************************************/

  static int i,j,po,calc_fail;
  static int loop_max,loop_num;
  static double r,dc,fv[3];
  static double p,p0,p1,v0,v1,v2,Ncore,Norm2;
  static double r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12;
  static double c2max,c2min,c0,c2,c4,c6,c8,c10,c12;
  static double DLN,DLN_max,DLN_min,DLN_p,pf1,pf2;
  static double a[ASIZE6][ASIZE6],b[ASIZE6],c[ASIZE6];
  static double a0[ASIZE6][ASIZE6];

  calc_fail = 0;
  loop_max = 10000;

  /****************************************************
        Input data from all electron calculation
  ****************************************************/

  Spline_Func(rc,fv,AEW);
  p0 = fv[0];
  p1 = fv[1];
  Spline_Func(rc,fv,AEV);
  v0 = fv[0];
  v1 = fv[1];
  v2 = fv[2];
  Ncore = scale_factor*Norm_Core(AEW,rc);

  b[0] = log(p0/pow(rc,(double)l+1.0));
  b[1] = p1/p0 - ((double)l + 1.0)/rc;
  b[2] = 2.0*v0 - 2.0*ep - 2.0*b[1]*((double)l + 1.0)/rc - b[1]*b[1];
  b[3] = 2.0*v1 + 2.0*b[1]*((double)l + 1.0)/rc/rc
        -2.0*b[2]*((double)l + 1.0)/rc - 2.0*b[1]*b[2];
  b[4] = 2.0*v2 - 4.0*b[1]*((double)l + 1.0)/rc/rc/rc
         + 4.0*b[2]*((double)l + 1.0)/rc/rc
         - 2.0*b[3]*((double)l + 1.0)/rc - 2.0*b[2]*b[2] - 2.0*b[1]*b[3];

  r2  = rc*rc;
  r3  = r2*rc;
  r4  = r2*r2;
  r5  = r4*rc;
  r6  = r4*r2;
  r7  = r6*rc;
  r8  = r4*r4;
  r9  = r8*rc;
  r10 = r8*r2;
  r11 = r10*rc;
  r12 = r10*r2;

  a[0][0] = 1.0;
  a[0][1] = r6;
  a[0][2] = r8; 
  a[0][3] = r10; 
  a[0][4] = r12; 

  a[1][0] = 0.0;
  a[1][1] = 6.0*r5;
  a[1][2] = 8.0*r7; 
  a[1][3] = 10.0*r9; 
  a[1][4] = 12.0*r11;

  a[2][0] = 0.0;
  a[2][1] = 30.0*r4;
  a[2][2] = 56.0*r6; 
  a[2][3] = 90.0*r8; 
  a[2][4] = 132.0*r10;

  a[3][0] = 0.0;
  a[3][1] = 120.0*r3;
  a[3][2] = 336.0*r5; 
  a[3][3] = 720.0*r7; 
  a[3][4] = 1320.0*r9;

  a[4][0] = 0.0;
  a[4][1] = 360.0*r2;
  a[4][2] = 1680.0*r4; 
  a[4][3] = 5040.0*r6; 
  a[4][4] = 11880.0*r8;

  for (i=0; i<=4; i++){
    for (j=0; j<=4; j++){
      a0[i][j] = a[i][j];
    }
  }

  /****************************************************
           Search the upper and lower points
              of the bisection method
  ****************************************************/

  po = 0;
  c2 = -20.0;
  dc = 0.03;
  loop_num = 0;

  DLN_p = Dlog_Norm(l,a,a0,b,c,c2,Ncore,rc,r2,r3,r4);

  do {
    c2 = c2 + dc;
    DLN = Dlog_Norm(l,a,a0,b,c,c2,Ncore,rc,r2,r3,r4);
    if (DLN*DLN_p<0.0){
      po = 1;
      c2max = c2;
      c2min = c2 - dc;
      DLN_max = DLN; 
      DLN_min = DLN_p;
    }
    else{
      DLN_p = DLN;
    }

    loop_num++;      

    if (loop_max<loop_num){

      if (calc_type==0 || calc_type==2){  
        printf("********************************************************\n");
        printf("Could not find an appropriate value of the parameter c2\n");
        printf("in the pseudo potential generation by the TM scheme.\n");
        printf("Please check cutoff radii of both pseudo potentials and\n");
        printf("pseudo atomic oribtals\n");
        printf("********************************************************\n");
        exit(0); 
      }
      else if (calc_type==1){
        calc_fail = 1;
        return calc_fail;
      }  
    }

  } while (po==0);

  /****************************************************
                  find c2 by bisection
  ****************************************************/

  po = 0;
  loop_num = 0;
  do {
    c2 = 0.50*(c2min + c2max);
    DLN = Dlog_Norm(l,a,a0,b,c,c2,Ncore,rc,r2,r3,r4);
    if (sgn(DLN)==sgn(DLN_min)){
      DLN_min = DLN;
      c2min = c2;
    }
    else{
      DLN_max = DLN;
      c2max = c2;
    }
    if (fabs(DLN)<=0.000000000001) po = 1;

    loop_num++;      

    if (loop_max<loop_num){
      printf("********************************************************\n");
      printf("Failure in searching of an appropriate c2\n");
      printf("in the pseudo potential generation by the TM scheme.\n");
      printf("Please check cutoff radii of both pseudo potentials and\n");
      printf("pseudo atomic oribtals\n");
      printf("********************************************************\n");
      exit(0); 
    }

  } while (po==0);

  c0  = c[0];
  c4  = c[5]; 
  c6  = c[1];
  c8  = c[2];
  c10 = c[3];
  c12 = c[4];

  /****************************************************
                       W2 and VPS
  ****************************************************/

  for (i=0; i<Grid_Num; i++){
    r = MRV[i]; 
    if (r<=rc){
      r2  = r*r;
      r3  = r2*r; 
      r4  = r2*r2;
      r5  = r4*r;
      r6  = r4*r2;
      r7  = r6*r;
      r8  = r4*r4;
      r9  = r8*r;
      r10 = r8*r2;
      r11 = r10*r;
      r12 = r10*r2;

      p = c0 + c2*r2 + c4*r4 + c6*r6 + c8*r8 + c10*r10 + c12*r12;
      pf1 = 2.0*c2*r + 4.0*c4*r3 + 6.0*c6*r5 + 8.0*c8*r7
	+ 10.0*c10*r9 + 12.0*c12*r11;
      pf2 = 2.0*c2 + 12.0*c4*r2 + 30.0*c6*r4 + 56.0*c8*r6
	+ 90.0*c10*r8 + 132.0*c12*r10;

      PW[i] = pow(r,(double)l+1.0)*exp(p);

      if (calc_type==0){
	PV[i] = ep + ((double)l + 1.0)*pf1/r + 0.5*(pf2 + pf1*pf1);
      }
      else if (calc_type==2){
	PV[i] =  ((double)l*((double)l+1.0)*pow(r,(double)l-1.0)
                + 2.0*((double)l+1.0)*pow(r,(double)l)*pf1
                + pow(r,(double)l+1.0)*(pf2 + pf1*pf1))*exp(p);
      }
    }
    else{
      PW[i] = AEW[i];
      PV[i] = AEV[i];
    }
  }

  return calc_fail;
}

double ip_phi0_phi1(double phi0[ASIZE1],double phi1[ASIZE1],double rc)
{
  static int i,n,j,l,nf,fg;
  static double r,rmin,rmax,Sr,Dr,sum,dum;
  static double fv0[3],fv1[3];

  n = ASIZE7-2;
  nf = n;
  fg = 1;

  Gauss_Legendre(n,x,w,&nf,&fg);

  rmin = MRV[0];
  rmax = rc;
  Sr = rmax + rmin;
  Dr = rmax - rmin;

  sum = 0.0;
  for (i=0; i<=(n-1); i++){
    r = 0.50*(Dr*x[i] + Sr);
    Spline_Func(r,fv0,phi0);
    Spline_Func(r,fv1,phi1);
    sum = sum + 0.5*Dr*fv0[0]*fv1[0]*w[i];
  }

  return sum;
}


void Calc_new_range(/*input */
		    int *node_c_ene, double *DD_c_ene, int num_nodes, 
		    /*output*/
		    double *MinE, double *MaxE , double *dE, int *num_div )
     /* find min and max of node_p==num_nodes */
{
  int num_min, num_max, found;
  found=0;
  for (num_min=0;num_min<*num_div;num_min++) {
    if ( node_c_ene[num_min]>= num_nodes ) {
      found=1;
      break;
    }
  }
  if (found==0) {
    num_min=0;
  }
  found=0;
  for (num_max=*num_div-1; num_max>=0; num_max--) {
    if ( node_c_ene[num_max] <= num_nodes ) {
      found=1;
      break;
    }
  }
  if (found==0) {
    num_max=*num_div-1;
  }
  /* order num_min < num_max  */
  if (num_min>num_max) {
    int i0=num_max;
    num_max=num_min;
    num_min = i0;
  }
  
  assert(num_max < *num_div);
#if 1
  if (num_max-num_min >= 5 ) {
     int num;
     int found=0;
     int num_smallest;
     double DD_c_val = 1.0e+10;
     /* find the smallest one */
     for (num=num_min;num<= num_max; num++) {
         if (node_c_ene[num]==num_nodes) {
            if (DD_c_val > DD_c_ene[num] ) {
                DD_c_val = DD_c_ene[num]; 
                num_smallest = num;
                found=1;
            }
         }
     }
     /* discrad found, DD_c_val */
     /* use num_smallest */
     if (found) {
        int num_try;
        /* try larger */ 
        num_try=num_smallest+1;
	if (num_try<*num_div)
        if (  node_c_ene[num_smallest-1] == node_c_ene[num_smallest] && 
	      node_c_ene[num_try]!=num_nodes ) {
            num_min = num_smallest-1;
#if 0
           printf("new num_min=%i\n",num_min);
#endif
            goto narrower_range_end;
        } 
        /* try smaller */
        num_try=num_smallest-1;
	if (num_try>=0) 
        if (  node_c_ene[num_smallest] == node_c_ene[num_smallest+1] &&
	      node_c_ene[num_try]!=num_nodes ) {
            num_max = num_smallest+1;
#if 0
            printf("new num_max=%i\n",num_max);
#endif
            goto narrower_range_end;
        }
     }
  narrower_range_end: ;
  }
#endif

  if (num_min>0) { num_min--; }
  if (num_max<*num_div-1) { num_max++;}


  {
    double saveMinE=*MinE;
    *MinE = saveMinE + *dE*num_min;
    *MaxE = saveMinE + *dE*num_max;
  }

  *num_div = 2*(num_max-num_min) + 1;

  *dE = (*MaxE - *MinE)/ ((*num_div) -1 );
/*  *dE ~= (*dE)*0.5; */
#if 0
  printf("num_min,num_max, num_div=%i %i %i\n",num_min,num_max,*num_div);
#endif
} 


void Calc_PAO(int state_num,
              int so, int n, int l, int num_nodes, double Reduce_Num_grid,
              double Vps[ASIZE1], double pw[ASIZE1])
{
  static int num,i,po,p,q,num_div,j,CTP_P;
  static int node_c,node_p,ref_switch,loop_num,loop_max;
  static int find_switch,match_p,match_p0;
  static int floop_num,floop_max;
  static double Mo[ASIZE1],Lo[ASIZE1],DMo[ASIZE1];
  static double Mi[ASIZE1],Li[ASIZE1],DMi[ASIZE1];
  static double MaxE,MinE,trial_ene,DD_c,DD_p,kappa;
  static double Deriv_O,Deriv_I,dE,ratio,tmp0;
  static double DD_MinE,DD_MaxE,Local_Ratio_MatP;
  int num_div_loop;
  double MinE0, MaxE0;
  int *node_c_ene;
  double *DD_c_ene; 
  const double eps=1.0e-10;

  printf("num_nodes=%i\n",num_nodes);
  /**************************************************
    search roughly
  ***************************************************/

/*  Local_Ratio_MatP = 0.60; */

  floop_max = 5;

  MinE0 = E[state_num][so][n][l] - 0.4;

  if (Calc_Type!=2){
       MaxE0 = -1.0e-4;
  }
  else{
       MaxE0 = smallest(height_wall,5.0);
  }
  CTP_P=10;

  for (floop_num=0; floop_num< floop_max; floop_num++ ) { /* loop to change Local_Ratio_MatP */

	  /* initial values for num_div loop */
    MinE = MinE0;
    MaxE = MaxE0;
    Local_Ratio_MatP = 0.60 + 0.1*floop_num ;
    printf("Local_Ratio_MatP=%lf\n",Local_Ratio_MatP);

    num_div =10;
    dE = (MaxE - MinE)/(double)(num_div-1);

    for (num_div_loop=0;num_div_loop<20; num_div_loop++) {
	    /* make dE smaller and smaller */

      DD_c_ene = (double*)malloc(sizeof(double)*(num_div));
      node_c_ene = (int*)malloc(sizeof(int)*(num_div));

#if 1
      printf("min,max,dE=%lf %lf %lf\n",MinE, MaxE, dE);
#endif
      find_switch = 0;
      DD_p = 0.0;
      DD_c = 0.0;

      trial_ene =MinE;
      num=0;
      while ( trial_ene<= MaxE + eps ) { 


	Hamming_O(0,l,trial_ene,kappa,Mo,Lo,DMo,Vps,Vps,Reduce_Num_grid);
	Hamming_I(0,l,trial_ene,kappa,Mi,Li,DMi,Vps,Vps,Reduce_Num_grid);

	/* Matching point */
	if (LL_grid<=UL_grid){
	  if (LL_grid<=(CTP+CTP_P) && (CTP+CTP_P)<=UL_grid){
	    match_p = Grid_Num*Local_Ratio_MatP*Reduce_Num_grid;
	  }
	  else{
	    match_p = (LL_grid + UL_grid)/2;
	  }
	}
	else{
	  printf("Could not find an appropriate matching point in TM.c\n");
	  exit(0);
	}

	/* Deviation between the derivatives for MinE */

	DD_p = DD_c;
	ratio = Lo[match_p]/Li[match_p];
	Deriv_O = Mo[match_p];
	Deriv_I = ratio*Mi[match_p];
	DD_c = Deriv_O - Deriv_I;

	/* recalc # of nodes */

	for (i=0; i<=match_p; i++)           pw[i] = Lo[i];
	for (i=(match_p+1); i<Grid_Num; i++) pw[i] = ratio*Li[i];
	node_p = node_c;
	node_c = 0;
	for (i=0; i<(Grid_Num-2); i++){
	  if (pw[i]*pw[i+1]<0.0) node_c++;
	}

	/* save it */
	assert( 0<=num );
	assert(num<num_div );
	node_c_ene[num] = node_c;
	DD_c_ene[num] = DD_c;

	printf("Rough l=%d trial_ene=%15.12f node_c=%d match_p=%4d DD_c=%15.12f\n",
	       l,trial_ene,node_c,match_p,DD_c);

	if ( (node_p==num_nodes && node_c==num_nodes) && DD_p*DD_c<0.0 ){

	  /*
	    printf("AA find_switch=%3d %10.6f %10.6f %10.6f\n",
	    find_switch,trial_ene,DD_p,DD_c);
	  */

	  find_switch = 1;
	  MaxE = trial_ene ; 
	  MinE = trial_ene - dE;
	  DD_MinE = DD_p;
	  DD_MaxE = DD_c;
	  match_p0 = match_p;
          
          free(DD_c_ene); free(node_c_ene); 

	  goto start_refine;
	}  

	trial_ene += dE;
	num++;
      } /* trial ene */

      /* new trial_ene */
      /* find min and max of node_p==num_nodes */
      Calc_new_range(/*input */   node_c_ene, DD_c_ene, num_nodes,
       /*output*/ &MinE,  &MaxE ,  &dE, &num_div );

      free(DD_c_ene); free(node_c_ene);

    } /* num_div_loop */

   /* failed to to find wf */

  } /* floop_num */

  {
    printf("Error: failed to find node.\n"
	   "What you can do is\n"
	   "1. tune Local_Ratio_MatP.\n"
	   "   increase max. of num_div.\n"
	   "2. report it to authors.\n");
    
    exit(0);
  }    

  /**************************************************
    refine 
  ***************************************************/

 start_refine:

  if (find_switch==1){

    po = 0;
    DD_p = 0.0;
    node_c = 100;
    loop_num = 0; 
    loop_max = 100; 

    do{

      loop_num++;

      trial_ene = 0.5*(MaxE + MinE);
      Hamming_O(0,l,trial_ene,kappa,Mo,Lo,DMo,Vps,Vps,Reduce_Num_grid);
      Hamming_I(0,l,trial_ene,kappa,Mi,Li,DMi,Vps,Vps,Reduce_Num_grid);
      
      /* Deviation between the derivatives for MinE */

      DD_p = DD_c;
      ratio = Lo[match_p0]/Li[match_p0];
      Deriv_O = Mo[match_p0];
      Deriv_I = ratio*Mi[match_p0];
      DD_c = Deriv_O - Deriv_I;

      /* recalc # of nodes */

      for (i=0; i<=match_p0; i++)           pw[i] = Lo[i];
      for (i=(match_p0+1); i<Grid_Num; i++) pw[i] = ratio*Li[i];
      node_p = node_c;
      node_c = 0;
      for (i=0; i<(Grid_Num-1); i++){
        if (pw[i]*pw[i+1]<0.0) node_c++;
      }

      /* bisection */

      if (sgn(DD_c)==sgn(DD_MaxE)){
        MaxE = trial_ene; 
        DD_MaxE = DD_c;
      }
      else {
        MinE = trial_ene; 
        DD_MinE = DD_c;
      }

      /* convergence? */
      if (fabs(DD_c)<1.0e-12) po = 1; 


      printf("Refine l=%d trial_ene=%15.12f node_c=%d match_p0=%4d DD_c=%15.12f\n",
              l,trial_ene,node_c,match_p0,DD_c);


      if ( po==0 && (loop_num==loop_max || (MaxE-MinE) < 1.0e-15) ) { 
        printf("Warning: not fully convergence in TM.c\n");
        printf("Please compare criterion and fabs(DD_c)\n");
        printf("criterion  = %18.15f\n",1.0e-12);   
        printf("fabs(DD_c) = %18.15f\n",fabs(DD_c));   
        printf("Acceptable or not??\n");
        po = 1;   
      }

    } while(po==0 && loop_num<loop_max);
  }
  else{
    printf("Could not find the eigenstate of VPS\n");
    exit(0);
  }


  if (po==1){
    for (i=0; i<=match_p0; i++){
      pw[i] = pow(MRV[i],(double)l+1.0)*Lo[i];
    }
    for (i=(match_p0+1); i<Grid_Num; i++){
      pw[i] = pow(MRV[i],(double)l+1.0)*ratio*Li[i];
    }
    tmp0 = 1.0/sqrt(ip_phi0_phi1(pw,pw,MRV[Grid_Num-1]));
    for (i=0; i<Grid_Num; i++){
      pw[i] = tmp0*pw[i];

      /*
      printf("%2d %2d %2d %15.12f %15.12f\n",so,n,l,MRV[i],pw[i]);
      */
    }
  }
  else{
    printf("Could not find the second orbital for L=%d in VPS\n",l);
    exit(0);
  }
}
